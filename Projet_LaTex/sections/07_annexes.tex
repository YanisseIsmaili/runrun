% Fichier : sections/07_annexes_techniques.tex
\section{Annexes Techniques}

\subsection{Configuration et installation}

Cette section fournit les informations d√©taill√©es n√©cessaires pour reproduire l'environnement de d√©veloppement et comprendre les d√©pendances techniques du projet Running App. Ces informations constituent une ressource pr√©cieuse pour l'√©valuation technique et la poursuite √©ventuelle du d√©veloppement.

L'environnement de d√©veloppement de Running App n√©cessite une configuration sp√©cifique qui √©quilibre simplicit√© d'installation et robustesse technique. Cette approche garantit que les d√©veloppeurs peuvent rapidement d√©marrer leur travail tout en b√©n√©ficiant d'un environnement stable et reproductible.

\subsubsection{Pr√©requis syst√®me}

L'installation compl√®te de l'environnement de d√©veloppement n√©cessite plusieurs composants qui doivent √™tre configur√©s dans un ordre sp√©cifique pour garantir le bon fonctionnement de l'ensemble du syst√®me. Cette s√©quence d'installation √©vite les conflits de d√©pendances et assure une configuration optimale.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Composant} & \textbf{Version} & \textbf{Description} \\
\hline
Node.js & 18.x ou sup√©rieur & Runtime JavaScript pour React Native \\
\hline
Python & 3.9 ou sup√©rieur & Interpr√©teur pour le backend Flask \\
\hline
MySQL & 8.0 ou sup√©rieur & Base de donn√©es relationnelle \\
\hline
Git & 2.30 ou sup√©rieur & Gestionnaire de versions \\
\hline
Android Studio & Derni√®re version & IDE pour le d√©veloppement Android \\
\hline
Xcode & 14 ou sup√©rieur & IDE pour le d√©veloppement iOS (macOS uniquement) \\
\hline
\end{tabular}
\caption{Pr√©requis techniques pour l'environnement de d√©veloppement}
\end{table}

La configuration de ces outils suit une s√©quence logique qui √©vite les conflits de d√©pendances et assure une installation stable. Python constitue le point de d√©part car Flask et ses extensions en d√©pendent directement. La configuration de MySQL n√©cessite une attention particuli√®re aux droits d'acc√®s et √† la configuration de s√©curit√© pour permettre le d√©veloppement local tout en pr√©parant le d√©ploiement en production.

Node.js et ses outils associ√©s forment l'√©cosyst√®me React Native qui permet le d√©veloppement cross-platform. L'installation d'Android Studio et Xcode compl√®te l'environnement en fournissant les SDK n√©cessaires pour compiler et tester l'application sur les appareils mobiles r√©els et les simulateurs.

\subsubsection{Installation du backend}

L'installation du backend Flask n√©cessite la cr√©ation d'un environnement virtuel Python qui isole les d√©pendances du projet et √©vite les conflits avec d'autres applications Python install√©es sur le syst√®me. Cette approche repr√©sente une bonne pratique qui facilite la maintenance et le d√©ploiement.

\begin{lstlisting}[language=bash, caption=Installation du backend Flask]
# Cr√©ation de l'environnement virtuel
python -m venv venv

# Activation de l'environnement (Windows)
venv\Scripts\activate

# Activation de l'environnement (macOS/Linux)
source venv/bin/activate

# Installation des d√©pendances
pip install -r requirements.txt

# Configuration de la base de donn√©es
python create_tables.py

# Cr√©ation d'un utilisateur administrateur
python scripts/create_admin.py admin admin@test.com Admin123!

# Lancement du serveur de d√©veloppement
python run.py
\end{lstlisting}

Le fichier requirements.txt contient toutes les d√©pendances Python n√©cessaires avec leurs versions sp√©cifiques pour garantir la reproductibilit√© de l'environnement. Cette approche √©vite les probl√®mes de compatibilit√© qui pourraient survenir avec des versions diff√©rentes des biblioth√®ques. La sp√©cification des versions exactes assure que tous les d√©veloppeurs travaillent avec le m√™me environnement technique.

La cr√©ation des tables de base de donn√©es s'effectue via un script d√©di√© qui utilise les mod√®les SQLAlchemy pour g√©n√©rer automatiquement la structure appropri√©e. Cette automatisation r√©duit les erreurs manuelles et facilite la mise en place d'environnements de d√©veloppement multiples.

\subsubsection{Installation du frontend mobile}

L'installation de l'application React Native s'appuie sur Node.js et npm pour g√©rer les d√©pendances JavaScript. L'utilisation d'Expo CLI simplifie consid√©rablement la configuration de l'environnement de d√©veloppement mobile en encapsulant la complexit√© des outils natifs.

\begin{lstlisting}[language=bash, caption=Installation du frontend React Native]
# Installation d'Expo CLI globalement
npm install -g @expo/cli

# Installation des d√©pendances du projet
npm install

# Configuration des variables d'environnement
cp .env.example .env

# Lancement en mode d√©veloppement
npx expo start

# Lancement sur un simulateur iOS (macOS uniquement)
npx expo run:ios

# Lancement sur un √©mulateur Android
npx expo run:android
\end{lstlisting}

La configuration des variables d'environnement permet d'adapter l'application aux diff√©rents environnements de d√©veloppement, test et production sans modifier le code source. Cette approche facilite le d√©ploiement et am√©liore la s√©curit√© en √©vitant le stockage de credentials dans le repository. Le fichier .env.example sert de template qui guide les d√©veloppeurs dans la configuration de leur environnement local.

\subsection{Extraits de code significatifs}

Cette section pr√©sente des extraits de code repr√©sentatifs qui illustrent les patterns architecturaux et les bonnes pratiques impl√©ment√©es dans le projet. Ces exemples d√©montrent la qualit√© technique du d√©veloppement et facilitent la compr√©hension de l'architecture globale du syst√®me.

\subsubsection{Authentification JWT c√¥t√© serveur}

L'impl√©mentation de l'authentification JWT illustre l'approche s√©curis√©e adopt√©e pour prot√©ger les endpoints de l'API. Ce code d√©montre la validation des credentials, la g√©n√©ration de tokens et la gestion structur√©e des erreurs qui am√©liore l'exp√©rience d√©veloppeur.

\begin{lstlisting}[language=python, caption=Endpoint d'authentification avec JWT]
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token
from werkzeug.security import check_password_hash
from app.models import User

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
    """Authentification utilisateur et g√©n√©ration du token JWT"""
    try:
        # Validation des donn√©es d'entr√©e avec messages explicites
        data = request.get_json()
        if not data or not data.get('email') or not data.get('password'):
            return jsonify({
                "status": "error",
                "message": "Email et mot de passe requis",
                "errors": {"auth": "Donn√©es manquantes"}
            }), 400
        
        # Recherche de l'utilisateur en base avec gestion de la casse
        user = User.query.filter_by(email=data['email'].lower()).first()
        
        # V√©rification s√©curis√©e des credentials
        if not user or not check_password_hash(user.password_hash, data['password']):
            return jsonify({
                "status": "error",
                "message": "Identifiants incorrects",
                "errors": {"auth": "Identifiants invalides"}
            }), 401
        
        # G√©n√©ration du token JWT avec claims personnalis√©s
        access_token = create_access_token(
            identity=user.id,
            additional_claims={
                "username": user.username,
                "email": user.email,
                "is_admin": user.is_admin
            }
        )
        
        # R√©ponse structur√©e avec informations utilisateur
        return jsonify({
            "status": "success",
            "message": "Connexion r√©ussie",
            "data": {
                "access_token": access_token,
                "user": user.to_dict()
            }
        }), 200
        
    except Exception as e:
        # Logging de l'erreur pour le d√©bogage
        app.logger.error(f"Erreur lors de la connexion: {str(e)}")
        return jsonify({
            "status": "error",
            "message": "Erreur lors de la connexion",
            "errors": {"server": "Erreur interne"}
        }), 500
\end{lstlisting}

Ce code illustre plusieurs bonnes pratiques importantes. La validation des entr√©es s'effectue d√®s le d√©but de la fonction pour √©viter les traitements inutiles. La recherche utilisateur normalise l'email en minuscules pour √©viter les probl√®mes de casse. La gestion d'erreurs distingue clairement les erreurs client des erreurs serveur tout en prot√©geant les informations sensibles.

\subsubsection{Composant React Native pour l'enregistrement de course}

Ce composant illustre l'int√©gration avec les APIs natives du smartphone et la gestion de l'√©tat complexe n√©cessaire pour l'enregistrement en temps r√©el des donn√©es de course. L'impl√©mentation d√©montre les bonnes pratiques React Native pour les applications de fitness.

\begin{lstlisting}[language=javascript, caption=Composant d'enregistrement de course]
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TouchableOpacity, Alert } from 'react-native';
import * as Location from 'expo-location';
import { useAuth } from '../contexts/AuthContext';
import { runAPI } from '../services/api';

const RunRecorder = () => {
  // √âtat du composant pour g√©rer l'enregistrement
  const [isRecording, setIsRecording] = useState(false);
  const [startTime, setStartTime] = useState(null);
  const [distance, setDistance] = useState(0);
  const [routeData, setRouteData] = useState([]);
  const [duration, setDuration] = useState(0);
  const [currentSpeed, setCurrentSpeed] = useState(0);
  
  // R√©f√©rence pour le subscription GPS (nettoyage automatique)
  const locationSubscription = useRef(null);
  
  const { user, token } = useAuth();

  // Effet pour mettre √† jour la dur√©e pendant l'enregistrement
  useEffect(() => {
    let interval;
    if (isRecording && startTime) {
      interval = setInterval(() => {
        setDuration(Math.floor((Date.now() - startTime) / 1000));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isRecording, startTime]);

  // Nettoyage automatique lors du d√©montage du composant
  useEffect(() => {
    return () => {
      if (locationSubscription.current) {
        locationSubscription.current.remove();
      }
    };
  }, []);

  // Fonction pour d√©marrer l'enregistrement avec gestion d'erreurs robuste
  const startRecording = async () => {
    try {
      // Demander les permissions de g√©olocalisation avec message explicite
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          'Permission requise', 
          'L\'acc√®s √† la g√©olocalisation est n√©cessaire pour enregistrer vos courses.'
        );
        return;
      }

      // V√©rifier la disponibilit√© du GPS
      const enabled = await Location.hasServicesEnabledAsync();
      if (!enabled) {
        Alert.alert(
          'GPS d√©sactiv√©', 
          'Veuillez activer la g√©olocalisation dans les param√®tres.'
        );
        return;
      }

      // Initialiser l'enregistrement avec √©tat coh√©rent
      setIsRecording(true);
      setStartTime(Date.now());
      setDistance(0);
      setRouteData([]);
      setDuration(0);
      setCurrentSpeed(0);

      // Configuration optimis√©e pour le suivi de course
      locationSubscription.current = await Location.watchPositionAsync(
        {
          accuracy: Location.Accuracy.High,
          timeInterval: 1000,  // Mise √† jour chaque seconde
          distanceInterval: 1, // Sensibilit√© au m√®tre
        },
        (location) => {
          // Validation de la qualit√© des donn√©es GPS
          if (location.coords.accuracy > 50) {
            // Ignorer les positions peu pr√©cises
            return;
          }

          // Cr√©er un nouveau point GPS avec m√©tadonn√©es
          const newPoint = {
            latitude: location.coords.latitude,
            longitude: location.coords.longitude,
            timestamp: location.timestamp,
            accuracy: location.coords.accuracy,
            speed: location.coords.speed || 0
          };
          
          setRouteData(prevData => {
            const newData = [...prevData, newPoint];
            
            // Calculer la distance incr√©mentale si on a au moins 2 points
            if (newData.length > 1) {
              const lastPoint = newData[newData.length - 2];
              const distanceToAdd = calculateDistance(lastPoint, newPoint);
              
              // Filtrer les distances aberrantes (plus de 100m en 1 seconde)
              if (distanceToAdd < 100) {
                setDistance(prevDistance => prevDistance + distanceToAdd);
              }
            }
            
            return newData;
          });

          // Mettre √† jour la vitesse instantan√©e
          setCurrentSpeed(location.coords.speed * 3.6 || 0); // Conversion m/s vers km/h
        }
      );
      
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de d√©marrer l\'enregistrement');
      console.error('Erreur d√©marrage course:', error);
      
      // R√©initialiser l'√©tat en cas d'erreur
      setIsRecording(false);
    }
  };

  // Fonction pour arr√™ter et sauvegarder la course
  const stopRecording = async () => {
    try {
      // Arr√™ter le suivi GPS imm√©diatement
      if (locationSubscription.current) {
        locationSubscription.current.remove();
        locationSubscription.current = null;
      }

      setIsRecording(false);
      const endTime = Date.now();
      
      // Validation des donn√©es avant sauvegarde
      if (duration < 30) {
        Alert.alert(
          'Course trop courte', 
          'La course doit durer au moins 30 secondes pour √™tre enregistr√©e.'
        );
        return;
      }

      if (distance < 50) {
        Alert.alert(
          'Distance insuffisante', 
          'La distance parcourue doit √™tre d\'au moins 50 m√®tres.'
        );
        return;
      }
      
      // Pr√©parer les donn√©es avec calculs de performance
      const avgSpeed = distance > 0 ? distance / duration : 0;
      const maxSpeed = Math.max(...routeData.map(point => point.speed || 0));
      
      const runData = {
        start_time: new Date(startTime).toISOString(),
        end_time: new Date(endTime).toISOString(),
        duration,
        distance: Math.round(distance),
        route_data: routeData,
        avg_speed: avgSpeed,
        max_speed: maxSpeed * 3.6, // Conversion en km/h
        calories: Math.round(distance * 0.06 * (user.weight || 70) / 70) // Estimation bas√©e sur le poids
      };

      // Sauvegarder avec indicateur de progression
      const result = await runAPI.createRun(runData, token);
      
      if (result.success) {
        Alert.alert(
          'Succ√®s', 
          `Course enregistr√©e!\nDistance: ${(distance/1000).toFixed(2)} km\nDur√©e: ${formatDuration(duration)}`
        );
        
        // R√©initialiser compl√®tement l'√©tat
        resetState();
      } else {
        Alert.alert('Erreur', '√âchec de l\'enregistrement de la course');
      }
      
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de sauvegarder la course');
      console.error('Erreur sauvegarde course:', error);
    }
  };

  // Fonction utilitaire pour r√©initialiser l'√©tat
  const resetState = () => {
    setStartTime(null);
    setDistance(0);
    setRouteData([]);
    setDuration(0);
    setCurrentSpeed(0);
  };

  // Calcul de distance optimis√© avec formule de Haversine
  const calculateDistance = (point1, point2) => {
    const R = 6371e3; // Rayon de la Terre en m√®tres
    const œÜ1 = point1.latitude * Math.PI/180;
    const œÜ2 = point2.latitude * Math.PI/180;
    const ŒîœÜ = (point2.latitude-point1.latitude) * Math.PI/180;
    const ŒîŒª = (point2.longitude-point1.longitude) * Math.PI/180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  };

  // Formatage de la dur√©e pour l'affichage
  const formatDuration = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Enregistrement de Course</Text>
      
      <View style={styles.statsContainer}>
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Dur√©e</Text>
          <Text style={styles.statValue}>{formatDuration(duration)}</Text>
        </View>
        
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Distance</Text>
          <Text style={styles.statValue}>{(distance / 1000).toFixed(2)} km</Text>
        </View>
        
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Allure</Text>
          <Text style={styles.statValue}>
            {distance > 0 ? (duration / (distance / 1000) / 60).toFixed(2) : '0.00'} min/km
          </Text>
        </View>
        
        <View style={styles.statItem}>
          <Text style={styles.statLabel}>Vitesse</Text>
          <Text style={styles.statValue}>{currentSpeed.toFixed(1)} km/h</Text>
        </View>
      </View>

      <TouchableOpacity
        style={[styles.button, isRecording ? styles.stopButton : styles.startButton]}
        onPress={isRecording ? stopRecording : startRecording}
        disabled={false}
      >
        <Text style={styles.buttonText}>
          {isRecording ? 'Arr√™ter la course' : 'D√©marrer la course'}
        </Text>
      </TouchableOpacity>
    </View>
  );
};

export default RunRecorder;
\end{lstlisting}

Ce composant d√©montre plusieurs aspects techniques importants. La gestion des permissions utilisateur suit les meilleures pratiques avec des messages explicites. Le suivi GPS utilise des param√®tres optimis√©s pour la course √† pied avec filtrage des donn√©es aberrantes. La gestion de l'√©tat React utilise des hooks appropri√©s avec nettoyage automatique des ressources.

\subsection{M√©triques et indicateurs de performance}

Le monitoring des performances constitue un aspect crucial pour maintenir la qualit√© de service et identifier proactivement les probl√®mes potentiels. Cette section pr√©sente les m√©triques cl√©s surveill√©es et leurs seuils d'alerte qui guident les d√©cisions d'optimisation.

\subsubsection{M√©triques backend}

Les m√©triques serveur permettent de surveiller la sant√© globale de l'API et d'identifier les goulots d'√©tranglement avant qu'ils n'impactent l'exp√©rience utilisateur. Cette approche pr√©ventive am√©liore la fiabilit√© du syst√®me.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{M√©trique} & \textbf{Objectif} & \textbf{Seuil d'alerte} & \textbf{Seuil critique} \\
\hline
Temps de r√©ponse API & < 200ms & 500ms & 1000ms \\
\hline
Taux d'erreur & < 1\% & 2\% & 5\% \\
\hline
Utilisation CPU & < 70\% & 80\% & 90\% \\
\hline
Utilisation m√©moire & < 80\% & 85\% & 95\% \\
\hline
Connexions DB actives & < 50 & 75 & 100 \\
\hline
Temps de requ√™te DB & < 50ms & 100ms & 200ms \\
\hline
D√©bit de requ√™tes & Variable & > 1000/min & > 2000/min \\
\hline
Taille du cache Redis & < 500MB & 750MB & 1GB \\
\hline
\end{tabular}
\caption{M√©triques de performance backend}
\end{table}

Ces m√©triques sont collect√©es en temps r√©el via des agents de monitoring qui agr√®gent les donn√©es sur diff√©rentes fen√™tres temporelles. Cette approche permet de d√©tecter aussi bien les pics ponctuels que les d√©gradations progressives de performance. L'historique de ces m√©triques facilite l'analyse des tendances et la planification de la capacit√© future.

Les seuils d'alerte sont calibr√©s selon l'exp√©rience op√©rationnelle et ajust√©s r√©guli√®rement selon l'√©volution du syst√®me. Les alertes de niveau critique d√©clenchent des interventions imm√©diates tandis que les alertes pr√©ventives permettent de planifier les optimisations.

\subsubsection{M√©triques frontend mobile}

Le monitoring de l'application mobile se concentre sur l'exp√©rience utilisateur et la performance per√ßue, aspects critiques pour l'adoption et la r√©tention des utilisateurs dans l'√©cosyst√®me mobile comp√©titif.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{M√©trique} & \textbf{Objectif} & \textbf{Description et importance} \\
\hline
Temps de d√©marrage & < 3 secondes & Dur√©e critique entre le lancement et l'√©cran principal utilisable \\
\hline
Fluidit√© d'animation & 60 FPS & Maintien des 60 images par seconde pour une exp√©rience native \\
\hline
Consommation batterie & < 5\%/heure & Impact sur l'autonomie pendant l'usage normal de l'application \\
\hline
Taux de crash & < 0.5\% & Pourcentage de sessions interrompues par un crash application \\
\hline
Pr√©cision GPS & < 5 m√®tres & √âcart moyen de localisation par rapport √† la position r√©elle \\
\hline
Latence r√©seau & < 300ms & Temps de r√©ponse des requ√™tes API depuis l'application \\
\hline
Taille de l'app & < 50MB & Espace de stockage occup√© apr√®s installation compl√®te \\
\hline
\end{tabular}
\caption{M√©triques de performance mobile}
\end{table}

Ces m√©triques mobile n√©cessitent des outils sp√©cialis√©s qui int√®grent avec les plateformes natives pour collecter les donn√©es de performance r√©elle. La mesure s'effectue sur des appareils repr√©sentatifs de la base utilisateur pour assurer la pertinence des donn√©es collect√©es.

\subsection{Proc√©dures de d√©ploiement}

La documentation des proc√©dures de d√©ploiement garantit la reproductibilit√© des mises en production et r√©duit les risques d'erreurs lors des livraisons. Ces proc√©dures √©voluent avec le projet pour int√©grer les le√ßons apprises et les am√©liorations process.

\subsubsection{D√©ploiement backend en production}

Le d√©ploiement du backend suit un processus automatis√© qui minimise les interventions manuelles et les risques d'erreurs. Cette proc√©dure inclut les v√©rifications de s√©curit√© et les tests de non-r√©gression obligatoires.

\begin{lstlisting}[language=bash, caption=Script de d√©ploiement backend production]
#!/bin/bash
# Script de d√©ploiement automatis√© pour le backend Flask
# Fichier: deploy_backend.sh

set -e  # Arr√™t imm√©diat en cas d'erreur

echo "üöÄ D√©but du d√©ploiement backend Running App"
echo "Environnement: PRODUCTION"
echo "Date: $(date '+%Y-%m-%d %H:%M:%S')"

# V√©rification des pr√©requis syst√®me
echo "üìã V√©rification de l'environnement de production"
python --version || exit 1
mysql --version || exit 1
nginx -v || exit 1

# V√©rification des variables d'environnement critiques
if [[ -z "$DB_PASSWORD" || -z "$JWT_SECRET_KEY" ]]; then
    echo "‚ùå Variables d'environnement manquantes"
    exit 1
fi

# Sauvegarde compl√®te de la base de donn√©es
echo "üíæ Sauvegarde de la base de donn√©es"
BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
mysqldump -u $DB_USER -p$DB_PASSWORD running_app_db > backups/$BACKUP_FILE
echo "Sauvegarde cr√©√©e: $BACKUP_FILE"

# Mise √† jour du code source avec v√©rification
echo "üì• R√©cup√©ration du code source"
git fetch origin
CURRENT_COMMIT=$(git rev-parse HEAD)
git checkout main
git pull origin main
NEW_COMMIT=$(git rev-parse HEAD)

echo "Commit pr√©c√©dent: $CURRENT_COMMIT"
echo "Nouveau commit: $NEW_COMMIT"

# Installation des d√©pendances avec cache pip
echo "üì¶ Installation des d√©pendances"
pip install --upgrade pip
pip install -r requirements.txt --no-deps

# Ex√©cution des migrations avec v√©rification
echo "üîÑ Application des migrations de base de donn√©es"
flask db upgrade

# V√©rification de l'int√©grit√© de la base apr√®s migration
echo "üîç V√©rification de l'int√©grit√© de la base de donn√©es"
python scripts/verify_db_integrity.py || exit 1

# Tests de validation complets
echo "üß™ Ex√©cution des tests de validation"
python -m pytest tests/ -v --tb=short || exit 1

# Tests d'int√©gration avec base de donn√©es r√©elle
echo "üîó Tests d'int√©gration"
python -m pytest tests/integration/ -v || exit 1

# Collecte des fichiers statiques
echo "üìÅ Collecte des fichiers statiques"
python manage.py collectstatic --noinput

# Red√©marrage gracieux des services
echo "üîÑ Red√©marrage des services"
sudo systemctl reload nginx
sudo systemctl restart running-app-backend
sudo systemctl restart running-app-worker  # Worker Celery si applicable

# Attente de la stabilisation des services
sleep 10

# V√©rifications de sant√© post-d√©ploiement
echo "üè• V√©rifications de sant√© de l'API"
for i in {1..5}; do
    if curl -f -s http://localhost:5000/api/health > /dev/null; then
        echo "‚úÖ API op√©rationnelle (tentative $i)"
        break
    else
        echo "‚è≥ Attente de l'API (tentative $i/5)"
        sleep 5
    fi
done

# Test des endpoints critiques
echo "üîç Test des endpoints critiques"
curl -f http://localhost:5000/api/auth/health || exit 1
curl -f http://localhost:5000/api/runs/health || exit 1
curl -f http://localhost:5000/api/proposed-runs/categories || exit 1

# Monitoring post-d√©ploiement
echo "üìä Initialisation du monitoring post-d√©ploiement"
python scripts/post_deploy_monitoring.py

echo "‚úÖ D√©ploiement termin√© avec succ√®s"
echo "üÜî Commit d√©ploy√©: $NEW_COMMIT"
echo "üìù Logs disponibles dans: /var/log/running-app/"
\end{lstlisting}

\subsubsection{Publication sur les app stores}

La publication de l'application mobile suit des processus sp√©cifiques √† chaque plateforme qui n√©cessitent une pr√©paration minutieuse et des tests approfondis sur diff√©rents appareils et versions de syst√®me.

Pour l'App Store iOS, la proc√©dure inclut plusieurs √©tapes critiques. La configuration des certificats de distribution n√©cessite une attention particuli√®re aux dates d'expiration et aux profils de provisioning. La g√©n√©ration du build avec Xcode suit des param√®tres sp√©cifiques pour optimiser la taille et les performances de l'application finale.

La soumission via App Store Connect implique la pr√©paration de m√©tadonn√©es d√©taill√©es, screenshots sur diff√©rentes tailles d'√©cran et la configuration des informations de publication. Le processus de review d'Apple peut prendre de 24 heures √† plusieurs jours selon la complexit√© de l'application et les √©ventuels probl√®mes d√©tect√©s.

Pour Google Play Store, le processus utilise Android Studio pour g√©n√©rer l'APK ou l'AAB sign√© avec les cl√©s de production. La configuration des m√©tadonn√©es inclut les descriptions multilingues, les cat√©gories appropri√©es et les informations de classification par √¢ge.

Le d√©ploiement progressif sur Google Play permet de limiter l'impact d'√©ventuels probl√®mes en d√©ployant d'abord sur un pourcentage limit√© d'utilisateurs avant le d√©ploiement complet. Cette approche graduelle am√©liore la qualit√© des mises √† jour et permet de d√©tecter les probl√®mes sur un √©chantillon r√©duit.

\subsection{Tests et validation}

La strat√©gie de tests garantit la qualit√© du code et la stabilit√© des fonctionnalit√©s tout au long du cycle de d√©veloppement. Cette approche multicouche couvre les tests unitaires, d'int√©gration et end-to-end pour assurer une couverture compl√®te des cas d'usage.

\subsubsection{Tests backend}

Les tests backend valident la logique m√©tier, les endpoints API et l'int√©gration avec la base de donn√©es. Ces tests utilisent pytest et des fixtures pour cr√©er des environnements de test reproductibles et isol√©s.

\begin{lstlisting}[language=python, caption=Suite de tests API compl√®te]
import pytest
import json
from datetime import datetime, timedelta
from app import create_app, db
from app.models import User, Run

@pytest.fixture(scope='function')
def test_app():
    """Application Flask configur√©e pour les tests"""
    app = create_app('testing')
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(test_app):
    """Client de test Flask"""
    return test_app.test_client()

@pytest.fixture
def test_user(test_app):
    """Utilisateur de test en base de donn√©es"""
    user = User(
        username="testuser",
        email="test@example.com",
        first_name="Test",
        last_name="User",
        password_hash=generate_password_hash("Test123!")
    )
    db.session.add(user)
    db.session.commit()
    return user

@pytest.fixture
def auth_headers(client, test_user):
    """Headers d'authentification JWT valides"""
    response = client.post('/api/auth/login', json={
        "email": "test@example.com",
        "password": "Test123!"
    })
    
    assert response.status_code == 200
    token = response.get_json()['data']['access_token']
    return {"Authorization": f"Bearer {token}"}

@pytest.fixture
def sample_run_data():
    """Donn√©es de course valides pour les tests"""
    now = datetime.utcnow()
    return {
        "start_time": now.isoformat() + "Z",
        "end_time": (now + timedelta(minutes=30)).isoformat() + "Z",
        "duration": 1800,
        "distance": 5000,
        "avg_speed": 2.78,
        "max_speed": 3.5,
        "calories": 350,
        "route_data": [
            {"latitude": 48.856614, "longitude": 2.3522219, "timestamp": now.timestamp()},
            {"latitude": 48.857614, "longitude": 2.3532219, "timestamp": (now + timedelta(minutes=15)).timestamp()},
            {"latitude": 48.858614, "longitude": 2.3542219, "timestamp": (now + timedelta(minutes=30)).timestamp()}
        ]
    }

class TestAuthenticationAPI:
    """Tests de l'authentification et autorisation"""
    
    def test_successful_login(self, client, test_user):
        """Test de connexion r√©ussie"""
        response = client.post('/api/auth/login', json={
            "email": "test@example.com",
            "password": "Test123!"
        })
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        assert 'access_token' in data['data']
        assert data['data']['user']['email'] == 'test@example.com'

    def test_invalid_credentials(self, client, test_user):
        """Test de connexion avec identifiants invalides"""
        response = client.post('/api/auth/login', json={
            "email": "test@example.com",
            "password": "WrongPassword"
        })
        
        assert response.status_code == 401
        data = response.get_json()
        assert data['status'] == 'error'
        assert 'access_token' not in data.get('data', {})

    def test_missing_credentials(self, client):
        """Test de connexion avec donn√©es manquantes"""
        response = client.post('/api/auth/login', json={
            "email": "test@example.com"
        })
        
        assert response.status_code == 400
        data = response.get_json()
        assert data['status'] == 'error'

class TestRunsAPI:
    """Tests des endpoints de gestion des courses"""
    
    def test_create_run_success(self, client, auth_headers, sample_run_data):
        """Test de cr√©ation d'une course valide"""
        response = client.post('/api/runs', 
                             json=sample_run_data, 
                             headers=auth_headers)
        
        assert response.status_code == 201
        data = response.get_json()
        assert data['status'] == 'success'
        assert data['data']['distance'] == 5000
        assert data['data']['duration'] == 1800

    def test_create_run_invalid_data(self, client, auth_headers):
        """Test de cr√©ation avec donn√©es invalides"""
        invalid_data = {
            "start_time": "invalid-date",
            "duration": -100,  # Dur√©e n√©gative
            "distance": "not-a-number"
        }
        
        response = client.post('/api/runs', 
                             json=invalid_data, 
                             headers=auth_headers)
        
        assert response.status_code == 400
        data = response.get_json()
        assert data['status'] == 'error'

    def test_get_user_runs(self, client, auth_headers, test_user):
        """Test de r√©cup√©ration des courses utilisateur"""
        # Cr√©er quelques courses de test
        for i in range(3):
            run = Run(
                user_id=test_user.id,
                start_time=datetime.utcnow() - timedelta(days=i),
                end_time=datetime.utcnow() - timedelta(days=i) + timedelta(minutes=30),
                duration=1800,
                distance=5000 + i * 1000
            )
            db.session.add(run)
        db.session.commit()
        
        response = client.get('/api/runs', headers=auth_headers)
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        assert len(data['data']['runs']) == 3

    def test_get_run_statistics(self, client, auth_headers, test_user):
        """Test des statistiques de course"""
        response = client.get('/api/runs/stats', headers=auth_headers)
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        assert 'total_runs' in data['data']
        assert 'total_distance' in data['data']

    def test_unauthorized_access(self, client, sample_run_data):
        """Test d'acc√®s non autoris√©"""
        response = client.post('/api/runs', json=sample_run_data)
        
        assert response.status_code == 401

class TestProposedRunsAPI:
    """Tests des courses propos√©es"""
    
    def test_get_proposed_runs_public(self, client):
        """Test d'acc√®s public aux courses propos√©es"""
        response = client.get('/api/proposed-runs')
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        assert 'runs' in data['data']
        assert len(data['data']['runs']) > 0

    def test_get_proposed_runs_filtered(self, client):
        """Test de filtrage des courses propos√©es"""
        response = client.get('/api/proposed-runs?difficulty=beginner&type=endurance')
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        
        # V√©rifier que le filtrage est appliqu√©
        for run in data['data']['runs']:
            assert run['difficulty'] == 'beginner'
            assert run['type'] == 'endurance'

    def test_get_run_categories(self, client):
        """Test de r√©cup√©ration des cat√©gories"""
        response = client.get('/api/proposed-runs/categories')
        
        assert response.status_code == 200
        data = response.get_json()
        assert data['status'] == 'success'
        assert 'difficulties' in data['data']
        assert 'types' in data['data']
        assert 'durations' in data['data']

class TestDataValidation:
    """Tests de validation des donn√©es"""
    
    def test_email_validation(self, client):
        """Test de validation des emails"""
        invalid_emails = [
            "invalid-email",
            "@domain.com",
            "user@",
            "user space@domain.com"
        ]
        
        for email in invalid_emails:
            response = client.post('/api/auth/register', json={
                "username": "testuser",
                "email": email,
                "password": "Test123!",
                "first_name": "Test",
                "last_name": "User"
            })
            
            assert response.status_code == 400

    def test_password_strength(self, client):
        """Test de validation de la force du mot de passe"""
        weak_passwords = [
            "123456",      # Trop simple
            "password",    # Pas de chiffres
            "Pass1",       # Trop court
            "PASSWORD123"  # Pas de minuscules
        ]
        
        for password in weak_passwords:
            response = client.post('/api/auth/register', json={
                "username": "testuser",
                "email": "test@example.com",
                "password": password,
                "first_name": "Test",
                "last_name": "User"
            })
            
            assert response.status_code == 400

class TestPerformance:
    """Tests de performance et charge"""
    
    def test_api_response_time(self, client, auth_headers):
        """Test des temps de r√©ponse API"""
        import time
        
        start_time = time.time()
        response = client.get('/api/runs', headers=auth_headers)
        end_time = time.time()
        
        response_time = end_time - start_time
        assert response_time < 1.0  # Moins d'une seconde
        assert response.status_code == 200

    def test_bulk_data_handling(self, client, auth_headers, test_user):
        """Test de gestion de volumes importants de donn√©es"""
        # Cr√©er un grand nombre de courses
        runs = []
        for i in range(100):
            run = Run(
                user_id=test_user.id,
                start_time=datetime.utcnow() - timedelta(days=i),
                end_time=datetime.utcnow() - timedelta(days=i) + timedelta(minutes=30),
                duration=1800,
                distance=5000
            )
            runs.append(run)
        
        db.session.add_all(runs)
        db.session.commit()
        
        # Tester la pagination
        response = client.get('/api/runs?page=1&per_page=20', headers=auth_headers)
        
        assert response.status_code == 200
        data = response.get_json()
        assert len(data['data']['runs']) == 20

# Configuration pytest
def pytest_configure(config):
    """Configuration globale des tests"""
    import warnings
    warnings.filterwarnings("ignore", category=DeprecationWarning)

# Ex√©cution des tests avec coverage
if __name__ == "__main__":
    pytest.main([
        "--verbose",
        "--tb=short",
        "--cov=app",
        "--cov-report=html",
        "--cov-report=term-missing"
    ])
\end{lstlisting}

Cette suite de tests couvre les aspects critiques de l'application avec une attention particuli√®re √† la s√©curit√©, la validation des donn√©es et les performances. L'utilisation de fixtures pytest facilite la r√©utilisation du code de test et garantit l'isolation entre les tests.

\subsubsection{Tests frontend mobile}

Les tests de l'application React Native combinent tests unitaires des composants, tests d'int√©gration et tests end-to-end pour valider l'exp√©rience utilisateur compl√®te.

\begin{lstlisting}[language=javascript, caption=Tests React Native avec Jest et React Native Testing Library]
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Alert } from 'react-native';
import * as Location from 'expo-location';

// Mocks des d√©pendances externes
jest.mock('expo-location');
jest.mock('../services/api');
jest.mock('../contexts/AuthContext');

import RunRecorder from '../components/RunRecorder';
import { runAPI } from '../services/api';
import { useAuth } from '../contexts/AuthContext';

describe('RunRecorder Component', () => {
  // Configuration des mocks
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock du contexte d'authentification
    useAuth.mockReturnValue({
      user: { id: 1, weight: 70 },
      token: 'mock-jwt-token'
    });
    
    // Mock des permissions GPS
    Location.requestForegroundPermissionsAsync.mockResolvedValue({
      status: 'granted'
    });
    
    Location.hasServicesEnabledAsync.mockResolvedValue(true);
  });

  test('renders initial state correctly', () => {
    const { getByText, getByTestId } = render(<RunRecorder />);
    
    expect(getByText('Enregistrement de Course')).toBeTruthy();
    expect(getByText('D√©marrer la course')).toBeTruthy();
    expect(getByText('0:00')).toBeTruthy(); // Dur√©e initiale
    expect(getByText('0.00 km')).toBeTruthy(); // Distance initiale
  });

  test('starts recording when start button is pressed', async () => {
    // Mock du suivi GPS
    const mockLocationSubscription = {
      remove: jest.fn()
    };
    
    Location.watchPositionAsync.mockResolvedValue(mockLocationSubscription);
    
    const { getByText } = render(<RunRecorder />);
    const startButton = getByText('D√©marrer la course');
    
    fireEvent.press(startButton);
    
    await waitFor(() => {
      expect(Location.requestForegroundPermissionsAsync).toHaveBeenCalled();
      expect(Location.watchPositionAsync).toHaveBeenCalled();
      expect(getByText('Arr√™ter la course')).toBeTruthy();
    });
  });

  test('handles GPS permission denial', async () => {
    // Mock du refus de permission
    Location.requestForegroundPermissionsAsync.mockResolvedValue({
      status: 'denied'
    });
    
    const alertSpy = jest.spyOn(Alert, 'alert');
    
    const { getByText } = render(<RunRecorder />);
    fireEvent.press(getByText('D√©marrer la course'));
    
    await waitFor(() => {
      expect(alertSpy).toHaveBeenCalledWith(
        'Permission requise',
        'L\'acc√®s √† la g√©olocalisation est n√©cessaire pour enregistrer vos courses.'
      );
    });
  });

  test('calculates distance correctly during recording', async () => {
    const mockLocationSubscription = {
      remove: jest.fn()
    };
    
    // Mock de la fonction de callback GPS
    let locationCallback;
    Location.watchPositionAsync.mockImplementation((options, callback) => {
      locationCallback = callback;
      return Promise.resolve(mockLocationSubscription);
    });
    
    const { getByText } = render(<RunRecorder />);
    fireEvent.press(getByText('D√©marrer la course'));
    
    await waitFor(() => {
      expect(locationCallback).toBeDefined();
    });
    
    // Simuler des points GPS
    const point1 = {
      coords: {
        latitude: 48.856614,
        longitude: 2.3522219,
        accuracy: 5,
        speed: 2.5
      },
      timestamp: Date.now()
    };
    
    const point2 = {
      coords: {
        latitude: 48.857614,
        longitude: 2.3532219,
        accuracy: 5,
        speed: 2.8
      },
      timestamp: Date.now() + 1000
    };
    
    // Envoyer les points GPS
    locationCallback(point1);
    locationCallback(point2);
    
    // V√©rifier que la distance est calcul√©e
    await waitFor(() => {
      const distanceText = getByText(/\d+\.\d+ km/);
      expect(distanceText).toBeTruthy();
    });
  });

  test('saves run data when stopped', async () => {
    // Mock de l'API de sauvegarde
    runAPI.createRun.mockResolvedValue({ success: true });
    
    const mockLocationSubscription = {
      remove: jest.fn()
    };
    
    Location.watchPositionAsync.mockResolvedValue(mockLocationSubscription);
    
    const { getByText } = render(<RunRecorder />);
    
    // D√©marrer l'enregistrement
    fireEvent.press(getByText('D√©marrer la course'));
    
    await waitFor(() => {
      expect(getByText('Arr√™ter la course')).toBeTruthy();
    });
    
    // Attendre suffisamment pour avoir une course valide (>30s)
    jest.advanceTimersByTime(35000);
    
    // Arr√™ter l'enregistrement
    fireEvent.press(getByText('Arr√™ter la course'));
    
    await waitFor(() => {
      expect(runAPI.createRun).toHaveBeenCalledWith(
        expect.objectContaining({
          duration: expect.any(Number),
          distance: expect.any(Number),
          route_data: expect.any(Array)
        }),
        'mock-jwt-token'
      );
    });
  });

  test('prevents saving short runs', async () => {
    const alertSpy = jest.spyOn(Alert, 'alert');
    
    const { getByText } = render(<RunRecorder />);
    
    // D√©marrer puis arr√™ter imm√©diatement
    fireEvent.press(getByText('D√©marrer la course'));
    
    await waitFor(() => {
      expect(getByText('Arr√™ter la course')).toBeTruthy();
    });
    
    // Avancer de seulement 20 secondes (insuffisant)
    jest.advanceTimersByTime(20000);
    
    fireEvent.press(getByText('Arr√™ter la course'));
    
    await waitFor(() => {
      expect(alertSpy).toHaveBeenCalledWith(
        'Course trop courte',
        'La course doit durer au moins 30 secondes pour √™tre enregistr√©e.'
      );
    });
    
    expect(runAPI.createRun).not.toHaveBeenCalled();
  });

  test('handles API errors gracefully', async () => {
    // Mock d'une erreur API
    runAPI.createRun.mockRejectedValue(new Error('Network error'));
    
    const alertSpy = jest.spyOn(Alert, 'alert');
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    
    const { getByText } = render(<RunRecorder />);
    
    fireEvent.press(getByText('D√©marrer la course'));
    
    await waitFor(() => {
      expect(getByText('Arr√™ter la course')).toBeTruthy();
    });
    
    jest.advanceTimersByTime(35000);
    fireEvent.press(getByText('Arr√™ter la course'));
    
    await waitFor(() => {
      expect(alertSpy).toHaveBeenCalledWith(
        'Erreur',
        'Impossible de sauvegarder la course'
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        'Erreur sauvegarde course:',
        expect.any(Error)
      );
    });
  });
});

// Tests d'int√©gration
describe('RunRecorder Integration Tests', () => {
  test('complete recording workflow', async () => {
    // Test complet du workflow d'enregistrement
    const { getByText } = render(<RunRecorder />);
    
    // 1. D√©marrer l'enregistrement
    fireEvent.press(getByText('D√©marrer la course'));
    
    // 2. Simuler une course compl√®te
    await waitFor(() => {
      expect(getByText('Arr√™ter la course')).toBeTruthy();
    });
    
    // 3. Avancer le temps et simuler des donn√©es GPS
    jest.advanceTimersByTime(60000); // 1 minute
    
    // 4. Arr√™ter et sauvegarder
    fireEvent.press(getByText('Arr√™ter la course'));
    
    // 5. V√©rifier le retour √† l'√©tat initial
    await waitFor(() => {
      expect(getByText('D√©marrer la course')).toBeTruthy();
    });
  });
});
\end{lstlisting}

\subsection{Glossaire technique}

Ce glossaire d√©finit les termes techniques sp√©cifiques utilis√©s dans le projet pour faciliter la compr√©hension et maintenir une terminologie coh√©rente entre les membres de l'√©quipe et les parties prenantes.

\begin{table}[h]
\centering
\small
\begin{tabularx}{\textwidth}{|p{3cm}|X|}
\hline
\textbf{Terme} & \textbf{D√©finition} \\
\hline
JWT & JSON Web Token - Standard de s√©curit√© RFC 7519 pour l'authentification stateless qui encapsule les informations d'identit√© dans un token sign√© cryptographiquement \\
\hline
REST & Representational State Transfer - Style d'architecture pour les APIs web qui utilise les verbes HTTP standard et repr√©sente les ressources par des URLs \\
\hline
ORM & Object-Relational Mapping - Technique de programmation qui permet de mapper les objets d'un langage orient√© objet avec les tables d'une base de donn√©es relationnelle \\
\hline
GPS & Global Positioning System - Syst√®me de g√©olocalisation par satellite qui fournit des coordonn√©es pr√©cises de latitude et longitude \\
\hline
Endpoint & Point d'acc√®s sp√©cifique d'une API REST identifi√© par une URL unique et associ√© √† une m√©thode HTTP \\
\hline
Blueprint & Module Flask qui organise les routes par domaine fonctionnel et facilite la modularit√© du code \\
\hline
Middleware & Composant logiciel qui intercepte et traite les requ√™tes HTTP avant qu'elles n'atteignent le contr√¥leur final \\
\hline
Hook & Fonction React qui permet d'utiliser l'√©tat et les effets de bord dans les composants fonctionnels \\
\hline
Hot Reload & Fonctionnalit√© de d√©veloppement qui recharge automatiquement l'application lors des modifications du code source \\
\hline
CI/CD & Continuous Integration/Continuous Deployment - Pratiques DevOps d'int√©gration et d√©ploiement continus qui automatisent les tests et les mises en production \\
\hline
Fixture & Donn√©es ou √©tat pr√©d√©finis utilis√©s dans les tests pour assurer la reproductibilit√© et l'isolation \\
\hline
Mock & Objet simul√© utilis√© dans les tests pour remplacer des d√©pendances externes et contr√¥ler leur comportement \\
\hline
Haversine & Formule math√©matique pour calculer la distance orthodromique entre deux points sur une sph√®re √† partir de leurs coordonn√©es \\
\hline
CORS & Cross-Origin Resource Sharing - M√©canisme de s√©curit√© web qui permet aux ressources d'un domaine d'√™tre accessibles depuis un autre domaine \\
\hline
\end{tabularx}
\caption{Glossaire des termes techniques}
\end{table}

\subsection{Ressources et documentation externe}

Cette section r√©f√©rence les ressources externes essentielles pour comprendre les technologies utilis√©es et poursuivre le d√©veloppement du projet. Ces r√©f√©rences constituent une biblioth√®que technique pour l'√©quipe de d√©veloppement.

\subsubsection{Documentation des frameworks principaux}

\begin{itemize}[leftmargin=1cm]
\item \textbf{Flask Documentation Officielle} : \url{https://flask.palletsprojects.com/} - Documentation compl√®te du micro-framework web Python incluant les guides d'installation, tutoriels et r√©f√©rences API
\item \textbf{React Native Documentation} : \url{https://reactnative.dev/} - Guide complet pour le d√©veloppement d'applications mobiles cross-platform avec React Native
\item \textbf{Expo Documentation} : \url{https://docs.expo.dev/} - Plateforme de d√©veloppement React Native qui simplifie la configuration et le d√©ploiement
\item \textbf{SQLAlchemy Documentation} : \url{https://docs.sqlalchemy.org/} - ORM Python utilis√© pour l'abstraction de la base de donn√©es
\end{itemize}

\subsubsection{Standards et sp√©cifications}

\begin{itemize}[leftmargin=1cm]
\item \textbf{RFC 7519 - JSON Web Token} : \url{https://tools.ietf.org/html/rfc7519} - Sp√©cification officielle du standard JWT pour l'authentification
\item \textbf{OpenAPI Specification} : \url{https://spec.openapis.org/oas/v3.1.0} - Standard pour documenter les APIs REST
\item \textbf{W3C Geolocation API} : \url{https://www.w3.org/TR/geolocation-API/} - Sp√©cification de l'API de g√©olocalisation web
\end{itemize}

\subsubsection{Outils de d√©veloppement}

\begin{itemize}[leftmargin=1cm]
\item \textbf{Jest Testing Framework} : \url{https://jestjs.io/} - Framework de test JavaScript utilis√© pour les tests unitaires React Native
\item \textbf{Pytest Documentation} : \url{https://docs.pytest.org/} - Framework de test Python pour les tests backend
\item \textbf{Docker Documentation} : \url{https://docs.docker.com/} - Plateforme de conteneurisation pour le d√©ploiement
\end{itemize}

\begin{successbox}[Documentation technique compl√®te]
Cette documentation technique fournit une base solide pour comprendre, maintenir et faire √©voluer l'application Running App. Les exemples de code, proc√©dures de d√©ploiement et suites de tests constituent des r√©f√©rences pratiques pour le d√©veloppement futur et l'optimisation continue du syst√®me. La structure modulaire facilite la mise √† jour de sections sp√©cifiques sans impacter l'ensemble de la documentation.
\end{successbox}

\begin{warningbox}[Maintenance de la documentation]
Cette documentation doit √™tre maintenue √† jour avec l'√©volution du projet. Chaque modification significative de l'architecture, des APIs ou des proc√©dures doit √™tre refl√©t√©e dans les sections correspondantes. Une revue trimestrielle de la documentation est recommand√©e pour assurer sa pertinence et son exactitude.
\end{warningbox}